
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>service: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">main/src/streams/application/service/stream_dynamodb_service.go (75.0%)</option>
				
				<option value="file1">main/src/streams/domain/model/stream.go (100.0%)</option>
				
				<option value="file2">main/src/streams/infrastructure/adapter/stream_dynamodb.go (78.6%)</option>
				
				<option value="file3">main/src/streams/infrastructure/configuration/dynamodb_stream_local.go (100.0%)</option>
				
				<option value="file4">main/utils/dynamodb/dynamodb_config.go (100.0%)</option>
				
				<option value="file5">main/utils/dynamodb/marshal.go (100.0%)</option>
				
				<option value="file6">main/utils/error/error.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package service

import (
        "log"
        "main/src/streams/domain/model"
        appError "main/utils/error"
        "main/src/streams/domain/repository"

        "github.com/google/uuid"
)

type StreamDynamoDBService struct {
        repo repository.StreamRepository
}

func NewStreamDynamoDBService(repo repository.StreamRepository) *StreamDynamoDBService <span class="cov8" title="1">{
        return &amp;StreamDynamoDBService{
                repo: repo,
        }
}</span>

func (service *StreamDynamoDBService) GetAllStream() ([]model.Stream, *appError.Error) <span class="cov8" title="1">{
        return service.repo.GetAllStream()
}</span>

func (service *StreamDynamoDBService) CreateStream(req *model.Stream) (*model.Stream, *appError.Error) <span class="cov8" title="1">{
        req.ID = uuid.NewString()
        if err := req.Validate(); err != nil </span><span class="cov0" title="0">{
                log.Printf("error while validating request from CreateStream Service: %v", err)
                return &amp;model.Stream{}, err
        }</span>

        <span class="cov8" title="1">return service.repo.CreateStream(req)</span>
}

func (service *StreamDynamoDBService) GetStreamById(stream_id string) (*model.Stream, *appError.Error) <span class="cov8" title="1">{
        return service.repo.GetStreamById(stream_id)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package model

import (
        appError "main/utils/error"
        "math"
        "regexp"
        "strings"
        "time"
)

type Stream struct {
    ID        string  `json:"ID,omitempty" dynamodbav:"ID,omitempty"`
    Name      string  `json:"name" dynamodbav:"name"`
    Cost      float64 `json:"cost" dynamodbav:"cost"`
    StartDate string  `json:"start_date" dynamodbav:"start_date"`
    EndDate   string  `json:"end_date" dynamodbav:"end_date"`
}

func (s Stream) Validate() *appError.Error <span class="cov8" title="1">{
        if err := validateUUID(s.ID); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := validateStringField(s.Name, 2); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := validateCost(s.Cost); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := validateDate(s.StartDate); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := validateDate(s.EndDate); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateUUID(id string) *appError.Error <span class="cov8" title="1">{
        uuidRegex := regexp.MustCompile(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89ab][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`)
        if !uuidRegex.MatchString(id) </span><span class="cov8" title="1">{
                return appError.NewValidationError("Invalid UUID format for ID")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateStringField(field string, minLength int) *appError.Error <span class="cov8" title="1">{
        if len(strings.TrimSpace(field)) &lt;= minLength </span><span class="cov8" title="1">{
                return appError.NewValidationError("Field length is less than required minimum")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateCost(cost float64) *appError.Error <span class="cov8" title="1">{
    if cost &lt; 0 </span><span class="cov8" title="1">{
        return appError.NewValidationError("Cost cannot be negative")
    }</span>
    <span class="cov8" title="1">if _, frac := math.Modf(cost * 100); frac != 0 </span><span class="cov8" title="1">{
        return appError.NewValidationError("Cost cannot have more than two decimal places")
    }</span>
    <span class="cov8" title="1">return nil</span>
}


func validateDate(dateStr string) *appError.Error <span class="cov8" title="1">{
        _, err := time.Parse(time.RFC3339, dateStr)
        if err != nil </span><span class="cov8" title="1">{
                if _, err := time.Parse(time.RFC3339Nano, dateStr); err != nil </span><span class="cov8" title="1">{
                        return appError.NewValidationError("Invalid date format, must be RFC3339 or RFC3339 with microseconds")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package adapter

import (
        "context"
        "log"
        "main/src/streams/domain/model"
        dynamodbUtils "main/utils/dynamodb"
        appError "main/utils/error"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

type StreamDynamoDBRepository struct {
        client *dynamodb.Client
        ctx    context.Context
        table  string
}

func NewStreamDynamoDBRepository(client *dynamodb.Client, ctx context.Context, table string) *StreamDynamoDBRepository <span class="cov8" title="1">{
        return &amp;StreamDynamoDBRepository{
                client: client,
                ctx:    ctx,
                table:  table,
        }
}</span>

func (repo *StreamDynamoDBRepository) GetAllStream() ([]model.Stream, *appError.Error) <span class="cov8" title="1">{
        var response []model.Stream

        input := &amp;dynamodb.ScanInput{
                TableName: aws.String(repo.table),
        }

        output, err := repo.client.Scan(repo.ctx, input)

        if err != nil </span><span class="cov0" title="0">{
        log.Printf("Scan error in GetAllStream: %v", err)
        return nil, appError.NewUnexpectedError("Error scanning DynamoDB table")
    }</span>

        <span class="cov8" title="1">for _, item := range output.Items </span><span class="cov8" title="1">{
                stream, _ := dynamodbUtils.UnmarshalStream(item)
                response = append(response, *stream)
        }</span>

        <span class="cov8" title="1">return response, nil</span>
}

func (repo *StreamDynamoDBRepository) CreateStream(stream *model.Stream) (*model.Stream, *appError.Error) <span class="cov8" title="1">{
        marshalStream, _ := dynamodbUtils.MarshalMapStream(stream)

    putInput := &amp;dynamodb.PutItemInput{
        Item:      marshalStream,
        TableName: aws.String(repo.table),
    }
        
        repo.client.PutItem(repo.ctx, putInput)

        return stream, nil
}</span>

func (repo *StreamDynamoDBRepository) GetStreamById(stream_id string) (*model.Stream, *appError.Error) <span class="cov8" title="1">{
        input := &amp;dynamodb.GetItemInput{
                TableName: aws.String(repo.table),
                Key: map[string]types.AttributeValue{
                        "ID": &amp;types.AttributeValueMemberS{Value: stream_id},
                },
        }

        result, err := repo.client.GetItem(repo.ctx, input)
    if err != nil </span><span class="cov0" title="0">{
        log.Printf("Error in GetItem: %v", err)
        return nil, appError.NewUnexpectedError("error retrieving stream")
    }</span>

        <span class="cov8" title="1">if result.Item == nil </span><span class="cov8" title="1">{
                log.Printf("GetStreamById: No item found with ID: %s", stream_id)
                return nil, appError.NewUnexpectedError("GetStreamById: No stream found with ID")
        }</span>

        <span class="cov8" title="1">stream, err := dynamodbUtils.UnmarshalStream(result.Item)
    if err != nil </span><span class="cov0" title="0">{
        log.Printf("Error unmarshalling stream: %v", err)
        return nil, appError.NewUnexpectedError("error unmarshalling stream")
    }</span>
        
        <span class="cov8" title="1">return stream, nil</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package configuration

import (
        "context"
        "fmt"
        "log"
        "os"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

var (
        STREAM_TABLE = os.Getenv("STREAM_TABLE")
)

func GetDynamoDBStreamTable() string <span class="cov8" title="1">{
        streamTable := os.Getenv("STREAM_TABLE")
        if streamTable == "" </span><span class="cov8" title="1">{
                log.Printf("Local DynamoDB Database")
                return "Test_Stream_Table"
        }</span>
        <span class="cov8" title="1">log.Printf("AWS DynamoDB Database: %s", streamTable)
        return streamTable</span>
}

func CreateLocalDynamoDBStreamTable(client *dynamodb.Client, ctx context.Context, tableName string) error <span class="cov8" title="1">{
        client.CreateTable(ctx, &amp;dynamodb.CreateTableInput{
                AttributeDefinitions: []types.AttributeDefinition{
                        {
                                AttributeName: aws.String("ID"),
                                AttributeType: types.ScalarAttributeTypeS,
                        },
                },
                KeySchema: []types.KeySchemaElement{
                        {
                                AttributeName: aws.String("ID"),
                                KeyType:       types.KeyTypeHash,
                        },
                },
                TableName:   aws.String(tableName),
                BillingMode: types.BillingModePayPerRequest,
        })
        log.Printf("Table %s created successfully", tableName)
        return nil
}</span>

func DeleteLocalDynamoDBStreamTable(client *dynamodb.Client, ctx context.Context, tableName string) error <span class="cov8" title="1">{
    _, err := client.DescribeTable(ctx, &amp;dynamodb.DescribeTableInput{
        TableName: aws.String(tableName),
    })

    if err != nil </span><span class="cov8" title="1">{
        return fmt.Errorf("table %s does not exist, no need to delete", tableName)
    }</span>
    <span class="cov8" title="1">client.DeleteTable(ctx, &amp;dynamodb.DeleteTableInput{
        TableName: aws.String(tableName),
    })

    log.Printf("Table %s deleted successfully", tableName)
    return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package dynamodb

import (
        "context"
        "log"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
)

func GetDynamoDBAWSClient(ctx context.Context) (*dynamodb.Client, error) <span class="cov8" title="1">{
        cfg, _ := config.LoadDefaultConfig(ctx)
        log.Printf("AWS Dynamo Client connected successfully")
        return dynamodb.NewFromConfig(cfg), nil
}</span>

func GetLocalEndpoint(service, region string, options ...interface{}) (aws.Endpoint, error) <span class="cov8" title="1">{
        return aws.Endpoint{URL: "http://localhost:8000"}, nil
}</span>

func GetLocalDynamoDBClient(ctx context.Context) (*dynamodb.Client, error) <span class="cov8" title="1">{
        cfg, _ := config.LoadDefaultConfig(ctx,
                config.WithEndpointResolverWithOptions(
                        aws.EndpointResolverWithOptionsFunc(
                                GetLocalEndpoint,
                        ),
                ),
        )
        log.Printf("Local Client connected successfully")
        return dynamodb.NewFromConfig(cfg), nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package dynamodb

import (
        "log"
        "main/src/streams/domain/model"

        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

func UnmarshalStream(item map[string]types.AttributeValue) (*model.Stream, error) <span class="cov8" title="1">{
        var stream model.Stream
        if err := attributevalue.UnmarshalMap(item, &amp;stream); err != nil </span><span class="cov8" title="1">{
                log.Printf("Error unmarshaling result: %s", err)
                return nil, err
        }</span>

    <span class="cov8" title="1">log.Printf("Unmarshalled Stream: %+v", stream)
        return &amp;stream, nil</span>
}

func MarshalMapStream(stream *model.Stream) (map[string]types.AttributeValue, error) <span class="cov8" title="1">{
        marshalStream, _ := attributevalue.MarshalMap(stream)
    log.Printf("Marshalled Stream: %+v", marshalStream)
        return marshalStream, nil
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package error

import (
        "errors"
        "net/http"
)

type Error struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
}

func (e *Error) ToString() string <span class="cov8" title="1">{
        return e.Message
}</span>

func (e *Error) ToError() error <span class="cov8" title="1">{
        return errors.New(e.ToString())
}</span>

func NewError(code int, message string) *Error <span class="cov8" title="1">{
        return &amp;Error{
                Code:    code,
                Message: message,
        }
}</span>

func NewNotFoundError(message string) *Error <span class="cov8" title="1">{
        return &amp;Error{
                Code: http.StatusNotFound,
                Message: message,
        }
}</span>

func NewUnexpectedError(message string) *Error <span class="cov8" title="1">{
        return &amp;Error{
                Code: http.StatusInternalServerError,
                Message: message,
        }
}</span>

func NewValidationError(message string) *Error <span class="cov8" title="1">{
        return &amp;Error{
                Code: http.StatusUnprocessableEntity,
                Message: message,
        }
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>

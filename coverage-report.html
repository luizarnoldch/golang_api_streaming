
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>service: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">main/src/streams/application/service/stream_dynamodb_service.go (80.0%)</option>
				
				<option value="file1">main/src/streams/domain/model/stream.go (100.0%)</option>
				
				<option value="file2">main/src/streams/infrastructure/adapter/stream_dynamodb.go (65.6%)</option>
				
				<option value="file3">main/src/streams/infrastructure/configuration/dynamodb_stream_local.go (76.0%)</option>
				
				<option value="file4">main/src/users/application/service/user_dynamodb_service.go (80.0%)</option>
				
				<option value="file5">main/src/users/domain/model/user.go (100.0%)</option>
				
				<option value="file6">main/src/users/infrastructure/adapter/user_dynamodb.go (67.2%)</option>
				
				<option value="file7">main/src/users/infrastructure/configuration/dynamodb_user_local.go (76.0%)</option>
				
				<option value="file8">main/utils/dynamodb/dynamodb_config.go (69.2%)</option>
				
				<option value="file9">main/utils/dynamodb/marshal.go (83.3%)</option>
				
				<option value="file10">main/utils/error/error.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package service

import (
        "log"
        "main/src/streams/domain/model"
        "main/src/streams/domain/repository"
        appError "main/utils/error"

        "github.com/google/uuid"
)

type StreamDynamoDBService struct {
        repo repository.StreamRepository
}

func NewStreamDynamoDBService(repo repository.StreamRepository) *StreamDynamoDBService <span class="cov8" title="1">{
        return &amp;StreamDynamoDBService{
                repo: repo,
        }
}</span>

func (service *StreamDynamoDBService) UpdateStreamById(stream_id string, stream *model.Stream) (*model.Stream, *appError.Error) <span class="cov8" title="1">{
        return service.repo.UpdateStreamById(stream_id, stream)
}</span>

func (service *StreamDynamoDBService) GetStreamById(stream_id string) (*model.Stream, *appError.Error) <span class="cov8" title="1">{
        return service.repo.GetStreamById(stream_id)
}</span>

func (service *StreamDynamoDBService) GetAllStream() ([]model.Stream, *appError.Error) <span class="cov8" title="1">{
        return service.repo.GetAllStream()
}</span>

func (service *StreamDynamoDBService) DeleteStream(stream_id string) *appError.Error <span class="cov8" title="1">{
        return service.repo.DeleteStream(stream_id)
}</span>

func (service *StreamDynamoDBService) CreateStream(req *model.Stream) (*model.Stream, *appError.Error) <span class="cov8" title="1">{
        req.ID = uuid.NewString()
        if err := req.Validate(); err != nil </span><span class="cov0" title="0">{
                log.Printf("error while validating request from CreateStream Service: %v", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return service.repo.CreateStream(req)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package model

import (
        appError "main/utils/error"
        "math"
        "regexp"
        "strings"
        "time"
)

type Stream struct {
    ID        string  `json:"ID,omitempty" dynamodbav:"ID,omitempty"`
    Name      string  `json:"name" dynamodbav:"name"`
    Cost      float64 `json:"cost" dynamodbav:"cost"`
    StartDate string  `json:"start_date" dynamodbav:"start_date"`
    EndDate   string  `json:"end_date" dynamodbav:"end_date"`
}

func (s Stream) Validate() *appError.Error <span class="cov8" title="1">{
        if err := ValidateUUID(s.ID); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := ValidateStringField(s.Name, 2); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := ValidateCost(s.Cost); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := ValidateDate(s.StartDate); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := ValidateDate(s.EndDate); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func ValidateUUID(id string) *appError.Error <span class="cov8" title="1">{
        uuidRegex := regexp.MustCompile(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$`)
        if !uuidRegex.MatchString(id) </span><span class="cov8" title="1">{
                return appError.NewValidationError("Invalid ID: The ID must be a valid UUID.")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func ValidateStringField(field string, minLength int) *appError.Error <span class="cov8" title="1">{
        if len(strings.TrimSpace(field)) &lt;= minLength </span><span class="cov8" title="1">{
                return appError.NewValidationError("Field length is less than required minimum")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func ValidateCost(cost float64) *appError.Error <span class="cov8" title="1">{
    if cost &lt; 0 </span><span class="cov8" title="1">{
        return appError.NewValidationError("Cost cannot be negative")
    }</span>
    <span class="cov8" title="1">if _, frac := math.Modf(cost * 100); frac != 0 </span><span class="cov8" title="1">{
        return appError.NewValidationError("Cost cannot have more than two decimal places")
    }</span>
    <span class="cov8" title="1">return nil</span>
}


func ValidateDate(dateStr string) *appError.Error <span class="cov8" title="1">{
        _, err := time.Parse(time.RFC3339, dateStr)
        if err != nil </span><span class="cov8" title="1">{
                if _, err := time.Parse(time.RFC3339Nano, dateStr); err != nil </span><span class="cov8" title="1">{
                        return appError.NewValidationError("Invalid date format, must be RFC3339 or RFC3339 with microseconds")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package adapter

import (
        "context"
        "log"
        "main/src/streams/domain/model"
        "main/src/streams/domain/repository"
        appError "main/utils/error"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression"
)

type StreamDynamoDBRepository struct {
        client *dynamodb.Client
        ctx    context.Context
        table  string
}

func NewStreamDynamoDBRepository(ctx context.Context, client *dynamodb.Client, table string) repository.StreamRepository <span class="cov8" title="1">{
        return &amp;StreamDynamoDBRepository{
                client: client,
                ctx:    ctx,
                table:  table,
        }
}</span>

func (repo *StreamDynamoDBRepository) UpdateStreamById(stream_id string, stream *model.Stream) (*model.Stream, *appError.Error) <span class="cov8" title="1">{
        updateBuilder := expression.Set(
                expression.Name("name"),expression.Value(stream.Name)).Set(
                expression.Name("cost"), expression.Value(stream.Cost)).Set(
                expression.Name("start_date"), expression.Value(stream.StartDate)).Set(
                expression.Name("end_date"), expression.Value(stream.StartDate))
        expr, err := expression.NewBuilder().WithUpdate(updateBuilder).Build()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error building expression for UpdateStreamById, %s", err.Error())
                return nil, appError.NewUnexpectedError(err.Error())
        }</span>

        <span class="cov8" title="1">input := &amp;dynamodb.UpdateItemInput{
                TableName: aws.String(repo.table),
                Key: map[string]types.AttributeValue{
                        "ID": &amp;types.AttributeValueMemberS{Value: stream_id},
                },
                UpdateExpression:          expr.Update(),
                ExpressionAttributeNames:  expr.Names(),
                ExpressionAttributeValues: expr.Values(),
                ReturnValues:              types.ReturnValueUpdatedNew,
        }

        output, err := repo.client.UpdateItem(repo.ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error updating stream UpdateStreamById, %s", err.Error())
                return nil, appError.NewUnexpectedError(err.Error())
        }</span>
        <span class="cov8" title="1">var updatedStream model.Stream
        if err := attributevalue.UnmarshalMap(output.Attributes, &amp;updatedStream); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error unmarshaling item UpdateStreamById, %s", err.Error())
                return nil, appError.NewUnexpectedError(err.Error())
        }</span>
        <span class="cov8" title="1">log.Printf("UpdateStreamById done successfully")
        return &amp;updatedStream, nil</span>
}

func (repo *StreamDynamoDBRepository) GetStreamById(stream_id string) (*model.Stream, *appError.Error) <span class="cov8" title="1">{
        input := &amp;dynamodb.GetItemInput{
                TableName: aws.String(repo.table),
                Key: map[string]types.AttributeValue{
                        "ID": &amp;types.AttributeValueMemberS{Value: stream_id},
                },
        }
        result, err := repo.client.GetItem(repo.ctx, input)
    if err != nil </span><span class="cov0" title="0">{
        log.Printf("Error in GetItem: %s", err.Error())
        return nil, appError.NewUnexpectedError(err.Error())
    }</span>
        <span class="cov8" title="1">if result.Item == nil </span><span class="cov0" title="0">{
                log.Printf("No item found with on GetStreamById, %s", stream_id)
                return nil, appError.NewUnexpectedError("No item found with on GetStreamById")
        }</span>
        <span class="cov8" title="1">var stream model.Stream
        if err := attributevalue.UnmarshalMap(result.Item, &amp;stream); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error unmarshaling item GetStreamById, %s", err.Error())
                return nil, appError.NewUnexpectedError(err.Error())
        }</span>
        <span class="cov8" title="1">log.Printf("GetStreamById done successfully")
        return &amp;stream, nil</span>
}

func (repo *StreamDynamoDBRepository) GetAllStream() ([]model.Stream, *appError.Error) <span class="cov8" title="1">{
        var response []model.Stream
        input := &amp;dynamodb.ScanInput{
                TableName: aws.String(repo.table),
        }
        output, err := repo.client.Scan(repo.ctx, input)
        if err != nil </span><span class="cov0" title="0">{
        log.Printf("Scan error in GetAllStream: %s", err.Error())
        return nil, appError.NewUnexpectedError(err.Error())
    }</span>
        <span class="cov8" title="1">for _, item := range output.Items </span><span class="cov8" title="1">{
                var stream model.Stream
                err := attributevalue.UnmarshalMap(item, &amp;stream)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error while unmarshaling item from GetAllStream, %s", err.Error())
                        return nil, appError.NewUnexpectedError(err.Error())
                }</span>
                <span class="cov8" title="1">response = append(response, stream)</span>
        }
        <span class="cov8" title="1">log.Printf("GetAllStream done successfully")
        return response, nil</span>
}

func (repo *StreamDynamoDBRepository) CreateStream(stream *model.Stream) (*model.Stream, *appError.Error) <span class="cov8" title="1">{
        marshalStream, err := attributevalue.MarshalMap(stream)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error while marshalling CreateStream input, %s", err.Error())
                return nil, appError.NewUnexpectedError(err.Error())
        }</span>
    <span class="cov8" title="1">input := &amp;dynamodb.PutItemInput{
        Item:      marshalStream,
        TableName: aws.String(repo.table),
    }
        _, err = repo.client.PutItem(repo.ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error while PutItem on CreateStream: %s", err.Error())
                return nil, appError.NewUnexpectedError(err.Error())
        }</span>
        <span class="cov8" title="1">log.Printf("CreateStream done successfully")
        return stream, nil</span>
}

func (repo *StreamDynamoDBRepository) DeleteStream(stream_id string) (*appError.Error) <span class="cov8" title="1">{
        input := &amp;dynamodb.DeleteItemInput{
                TableName: aws.String(repo.table),
                Key: map[string]types.AttributeValue{
                        "ID": &amp;types.AttributeValueMemberS{Value: stream_id},
                },
        }

        _, err := repo.client.DeleteItem(repo.ctx, input)
        if err != nil </span><span class="cov0" title="0">{
        log.Printf("Error while DeleteStream, %s", err.Error())
        return appError.NewUnexpectedError(err.Error())
    }</span>
        <span class="cov8" title="1">log.Printf("DeleteStream done successfully")
        return nil</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package configuration

import (
        "context"
        "errors"
        "fmt"
        "log"
        "os"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

func GetDynamoDBStreamTable() string <span class="cov8" title="1">{
        streamTable := os.Getenv("STREAM_TABLE")
        if streamTable == "" </span><span class="cov8" title="1">{
                log.Printf("Local DynamoDB Database")
                return "Test_Stream_Table"
        }</span>
        <span class="cov8" title="1">log.Printf("AWS DynamoDB Database: %s", streamTable)
        return streamTable</span>
}

func CreateLocalDynamoDBStreamTable(ctx context.Context, client *dynamodb.Client, tableName string) error <span class="cov8" title="1">{
        client.CreateTable(ctx, &amp;dynamodb.CreateTableInput{
                AttributeDefinitions: []types.AttributeDefinition{
                        {
                                AttributeName: aws.String("ID"),
                                AttributeType: types.ScalarAttributeTypeS,
                        },
                },
                KeySchema: []types.KeySchemaElement{
                        {
                                AttributeName: aws.String("ID"),
                                KeyType:       types.KeyTypeHash,
                        },
                },
                TableName:   aws.String(tableName),
                BillingMode: types.BillingModePayPerRequest,
        })
        log.Printf("Table %s created successfully", tableName)
        return nil
}</span>

func DescribeStreamTable(ctx context.Context, client *dynamodb.Client, tableName string) (bool, error) <span class="cov8" title="1">{
        _, err := client.DescribeTable(ctx, &amp;dynamodb.DescribeTableInput{
                TableName: aws.String(tableName),
        })

        if err != nil </span><span class="cov0" title="0">{
                var notFoundErr *types.ResourceNotFoundException
                if errors.As(err, &amp;notFoundErr) </span><span class="cov0" title="0">{
                        log.Printf("Table %s does not exist.", tableName)
                        return false, nil
                }</span>
                <span class="cov0" title="0">log.Printf("Unexpected error occurred while describing table %s: %s", tableName, err)
                return false, err</span>
        }

        <span class="cov8" title="1">log.Printf("Table %s exists.", tableName)
        return true, nil</span>
}

func DeleteLocalDynamoDBStreamTable(ctx context.Context, client *dynamodb.Client, tableName string) error <span class="cov8" title="1">{
    _, err := client.DescribeTable(ctx, &amp;dynamodb.DescribeTableInput{
        TableName: aws.String(tableName),
    })

    if err != nil </span><span class="cov8" title="1">{
        return fmt.Errorf("table %s does not exist, no need to delete", tableName)
    }</span>
    <span class="cov8" title="1">client.DeleteTable(ctx, &amp;dynamodb.DeleteTableInput{
        TableName: aws.String(tableName),
    })

    log.Printf("Table %s deleted successfully", tableName)
    return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package service

import (
        "log"
        "main/src/users/domain/model"
        "main/src/users/domain/repository"
        appError "main/utils/error"

        "github.com/google/uuid"
)

type userServiceImpl struct {
        userRepo repository.UserRepository
}

func NewUserService(userRepo repository.UserRepository) UserService <span class="cov8" title="1">{
        return &amp;userServiceImpl{userRepo: userRepo}
}</span>

func (service *userServiceImpl) CreateUser(user *model.User) (*model.User, *appError.Error) <span class="cov8" title="1">{
        user.ID = uuid.NewString()
        if err := user.Validate(); err != nil </span><span class="cov0" title="0">{
                log.Printf("error while validating request from CreateStream Service: %v", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">return service.userRepo.CreateUser(user)</span>
}

func (service *userServiceImpl) GetUserByID(userID string) (*model.User, *appError.Error) <span class="cov8" title="1">{
        return service.userRepo.GetUserByID(userID)
}</span>

func (service *userServiceImpl) UpdateUserByID(userID string, user *model.User) (*model.User, *appError.Error) <span class="cov8" title="1">{
        return service.userRepo.UpdateUserByID(userID, user)
}</span>

func (service *userServiceImpl) GetAllUser() ([]model.User, *appError.Error) <span class="cov8" title="1">{
        return service.userRepo.GetAllUser()
}</span>

func (service *userServiceImpl) DeleteUser(userID string) *appError.Error <span class="cov8" title="1">{
        return service.userRepo.DeleteUser(userID)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package model

import (
        appError "main/utils/error"
        "regexp"
        "strings"
        "time"
)

type User struct {
        ID        string `json:"ID,omitempty" dynamodbav:"ID,omitempty"`
        Name      string `json:"name" dynamodbav:"name"`
        Email     string `json:"email" dynamodbav:"email"`
        CreatedAt string `json:"created_at" dynamodbav:"created_at"`
}

func (u *User) Validate() *appError.Error <span class="cov8" title="1">{
        if err := ValidateUUID(u.ID); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := ValidateStringField(u.Name, 2); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := ValidateEmail(u.Email); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := ValidateDate(u.CreatedAt); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func ValidateUUID(id string) *appError.Error <span class="cov8" title="1">{
        uuidRegex := regexp.MustCompile(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$`)
        if !uuidRegex.MatchString(id) </span><span class="cov8" title="1">{
                return appError.NewValidationError("Invalid ID: The ID must be a valid UUID.")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func ValidateStringField(field string, minLength int) *appError.Error <span class="cov8" title="1">{
        if len(strings.TrimSpace(field)) &lt; minLength </span><span class="cov8" title="1">{
                return appError.NewValidationError("Field length is less than the required minimum")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func ValidateEmail(email string) *appError.Error <span class="cov8" title="1">{
        emailRegex := regexp.MustCompile(`^[a-z0-9._%+\-]+@[a-z0-9.\-]+\.[a-z]{2,4}$`)
        if !emailRegex.MatchString(email) </span><span class="cov8" title="1">{
                return appError.NewValidationError("Invalid email format")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func ValidateDate(dateStr string) *appError.Error <span class="cov8" title="1">{
        _, err := time.Parse(time.RFC3339, dateStr)
        if err != nil </span><span class="cov8" title="1">{
                return appError.NewValidationError("Invalid date format, must be RFC3339")
        }</span>
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file6" style="display: none">package adapter

import (
        "context"
        "log"
        "main/src/users/domain/model"
        "main/src/users/domain/repository"
        appError "main/utils/error"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

type UserDynamoDBRepository struct {
        client *dynamodb.Client
        ctx    context.Context
        table  string
}

func NewUserDynamoDBRepository(ctx context.Context, client *dynamodb.Client, table string) repository.UserRepository <span class="cov8" title="1">{
        return &amp;UserDynamoDBRepository{
                ctx:    ctx,
                client: client,
                table:  table,
        }
}</span>

func (repo *UserDynamoDBRepository) UpdateUserByID(userID string, user *model.User) (*model.User, *appError.Error) <span class="cov8" title="1">{
        updateBuilder := expression.Set(
                expression.Name("name"), expression.Value(user.Name)).Set(
                expression.Name("email"), expression.Value(user.Email))
        
        expr, err := expression.NewBuilder().WithUpdate(updateBuilder).Build()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error building expression for UpdateUserByID, %s", err.Error())
                return nil, appError.NewUnexpectedError(err.Error())
        }</span>

        <span class="cov8" title="1">input := &amp;dynamodb.UpdateItemInput{
                TableName: aws.String(repo.table),
                Key: map[string]types.AttributeValue{
                        "ID": &amp;types.AttributeValueMemberS{Value: userID},
                },
                UpdateExpression:          expr.Update(),
                ExpressionAttributeNames:  expr.Names(),
                ExpressionAttributeValues: expr.Values(),
                ReturnValues:              types.ReturnValueUpdatedNew,
        }

        output, err := repo.client.UpdateItem(repo.ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error updating stream UpdateUserByID, %s", err.Error())
                return nil, appError.NewUnexpectedError(err.Error())
        }</span>
        <span class="cov8" title="1">var updatedUser model.User
        if err := attributevalue.UnmarshalMap(output.Attributes, &amp;updatedUser); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error unmarshaling UpdateUserByID, %s", err.Error())
                return nil, appError.NewUnexpectedError(err.Error())
        }</span>
        <span class="cov8" title="1">log.Printf("UpdateUserByID done successfully")
        return &amp;updatedUser, nil</span>
}

func (repo *UserDynamoDBRepository) GetUserByID(userID string) (*model.User, *appError.Error) <span class="cov8" title="1">{
        input := &amp;dynamodb.GetItemInput{
                TableName: aws.String(repo.table),
                Key: map[string]types.AttributeValue{
                        "ID": &amp;types.AttributeValueMemberS{Value: userID},
                },
        }
        result, err := repo.client.GetItem(repo.ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting item from DynamoDB: %v", err)
                return nil, appError.NewUnexpectedError("Failed to get item from DynamoDB")
        }</span>
        <span class="cov8" title="1">if result.Item == nil </span><span class="cov0" title="0">{
                return nil, appError.NewNotFoundError("User not found")
        }</span>
        <span class="cov8" title="1">user := &amp;model.User{}
        err = attributevalue.UnmarshalMap(result.Item, user)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error unmarshalling DynamoDB item to user: %v", err)
                return nil, appError.NewUnexpectedError("Failed to unmarshal DynamoDB item to user")
        }</span>
        <span class="cov8" title="1">log.Printf("GetUserByID done successfully")
        return user, nil</span>
}

func (repo *UserDynamoDBRepository) GetAllUser() ([]model.User, *appError.Error) <span class="cov8" title="1">{
        input := &amp;dynamodb.ScanInput{
                TableName: aws.String(repo.table),
        }
        result, err := repo.client.Scan(repo.ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error scanning DynamoDB table: %v", err)
                return nil, appError.NewUnexpectedError("Failed to scan DynamoDB table")
        }</span>
        <span class="cov8" title="1">users := []model.User{}
        for _, item := range result.Items </span><span class="cov8" title="1">{
                user := model.User{}
                err := attributevalue.UnmarshalMap(item, &amp;user)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error unmarshalling item to user: %v", err)
                        continue</span>
                }
                <span class="cov8" title="1">users = append(users, user)</span>
        }
        <span class="cov8" title="1">log.Printf("GetAllUser done successfully")
        return users, nil</span>
}

func (repo *UserDynamoDBRepository) CreateUser(user *model.User) (*model.User, *appError.Error) <span class="cov8" title="1">{
        av, err := attributevalue.MarshalMap(user)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshalling user: %v", err)
                return nil, appError.NewUnexpectedError("Failed to marshal user")
        }</span>
        <span class="cov8" title="1">input := &amp;dynamodb.PutItemInput{
                Item:      av,
                TableName: aws.String(repo.table),
        }
        _, err = repo.client.PutItem(repo.ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error putting item to DynamoDB: %v", err)
                return nil, appError.NewUnexpectedError("Failed to put item into DynamoDB")
        }</span>
        <span class="cov8" title="1">log.Printf("CreateUser done successfully")
        return user, nil</span>
}

func (repo *UserDynamoDBRepository) DeleteUser(userID string) *appError.Error <span class="cov8" title="1">{
        input := &amp;dynamodb.DeleteItemInput{
                TableName: aws.String(repo.table),
                Key: map[string]types.AttributeValue{
                        "ID": &amp;types.AttributeValueMemberS{Value: userID},
                },
        }
        _, err := repo.client.DeleteItem(repo.ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error deleting item from DynamoDB: %v", err)
                return appError.NewUnexpectedError("Failed to delete item from DynamoDB")
        }</span>
        <span class="cov8" title="1">log.Printf("DeleteUser done successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package configuration

import (
        "context"
        "errors"
        "fmt"
        "log"
        "os"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

func GetDynamoDBUserTable() string <span class="cov8" title="1">{
        userTable := os.Getenv("USER_TABLE")
        if userTable == "" </span><span class="cov8" title="1">{
                log.Printf("Local DynamoDB Database")
                return "Test_User_Table"
        }</span>
        <span class="cov8" title="1">log.Printf("AWS DynamoDB Database: %s", userTable)
        return userTable</span>
}

func CreateLocalDynamoDBUserTable(ctx context.Context, client *dynamodb.Client, tableName string) error <span class="cov8" title="1">{
        client.CreateTable(ctx, &amp;dynamodb.CreateTableInput{
                AttributeDefinitions: []types.AttributeDefinition{
                        {
                                AttributeName: aws.String("ID"),
                                AttributeType: types.ScalarAttributeTypeS,
                        },
                },
                KeySchema: []types.KeySchemaElement{
                        {
                                AttributeName: aws.String("ID"),
                                KeyType:       types.KeyTypeHash,
                        },
                },
                TableName:   aws.String(tableName),
                BillingMode: types.BillingModePayPerRequest,
        })
        log.Printf("Table %s created successfully", tableName)
        return nil
}</span>

func DescribeUserTable(ctx context.Context, client *dynamodb.Client, tableName string) (bool, error) <span class="cov8" title="1">{
        _, err := client.DescribeTable(ctx, &amp;dynamodb.DescribeTableInput{
                TableName: aws.String(tableName),
        })

        if err != nil </span><span class="cov0" title="0">{
                var notFoundErr *types.ResourceNotFoundException
                if errors.As(err, &amp;notFoundErr) </span><span class="cov0" title="0">{
                        log.Printf("Table %s does not exist.", tableName)
                        return false, nil
                }</span>
                <span class="cov0" title="0">log.Printf("Unexpected error occurred while describing table %s: %s", tableName, err)
                return false, err</span>
        }

        <span class="cov8" title="1">log.Printf("Table %s exists.", tableName)
        return true, nil</span>
}

func DeleteLocalDynamoDBUserTable(ctx context.Context, client *dynamodb.Client, tableName string) error <span class="cov8" title="1">{
    _, err := client.DescribeTable(ctx, &amp;dynamodb.DescribeTableInput{
        TableName: aws.String(tableName),
    })

    if err != nil </span><span class="cov8" title="1">{
        return fmt.Errorf("table %s does not exist, no need to delete", tableName)
    }</span>
    <span class="cov8" title="1">client.DeleteTable(ctx, &amp;dynamodb.DeleteTableInput{
        TableName: aws.String(tableName),
    })

    log.Printf("Table %s deleted successfully", tableName)
    return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package dynamodb

import (
        "context"
        "log"
        "os"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/aws/retry"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
)

func GetDynamoDBAWSClient(ctx context.Context) (*dynamodb.Client, error) <span class="cov8" title="1">{
        if (os.Getenv("ENV") == "dev") </span><span class="cov0" title="0">{
                log.Println(os.Getenv("ENV"))
                return GetLocalDynamoDBClient(ctx)
        }</span>
        
        <span class="cov8" title="1">cfg, err := config.LoadDefaultConfig(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("error while getting client from AWS")
                return nil, err
        }</span>
        <span class="cov8" title="1">return dynamodb.NewFromConfig(cfg), nil</span>
}

func GetLocalEndpoint(service, region string, options ...interface{}) (aws.Endpoint, error) <span class="cov8" title="1">{
        return aws.Endpoint{URL: "http://localhost:8000"}, nil
}</span>

func GetLocalDynamoDBClient(ctx context.Context) (*dynamodb.Client, error) <span class="cov8" title="1">{
        cfg, _ := config.LoadDefaultConfig(ctx,
                config.WithEndpointResolverWithOptions(
                        aws.EndpointResolverWithOptionsFunc(
                                GetLocalEndpoint,
                        ),
                ),
                config.WithRetryer(func() aws.Retryer </span><span class="cov8" title="1">{
                        return retry.AddWithMaxAttempts(retry.NewStandard(), 5) // Increase max attempts
                }</span>),
        )
        <span class="cov8" title="1">log.Printf("Local Client connected successfully")
        return dynamodb.NewFromConfig(cfg), nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package dynamodb

import (
        "log"
        "main/src/streams/domain/model"

        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

func UnmarshalStream(item map[string]types.AttributeValue) (*model.Stream, error) <span class="cov8" title="1">{
        var stream model.Stream
        if err := attributevalue.UnmarshalMap(item, &amp;stream); err != nil </span><span class="cov8" title="1">{
                log.Printf("Error unmarshaling result: %s", err)
                return nil, err
        }</span>
    <span class="cov8" title="1">log.Printf("Unmarshalled Stream: %+v", stream)
        return &amp;stream, nil</span>
}

func MarshalMapStream(stream *model.Stream) (map[string]types.AttributeValue, error) <span class="cov8" title="1">{
        marshalStream, err := attributevalue.MarshalMap(stream)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling result: %s", err)
                return nil, err
        }</span>
    <span class="cov8" title="1">log.Printf("Marshalled Stream: %+v", marshalStream)
        return marshalStream, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package error

import (
        "errors"
        "net/http"
)

type Error struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
}

func (e *Error) ToString() string <span class="cov8" title="1">{
        return e.Message
}</span>

func (e *Error) ToError() error <span class="cov8" title="1">{
        return errors.New(e.ToString())
}</span>

func NewError(code int, message string) *Error <span class="cov8" title="1">{
        return &amp;Error{
                Code:    code,
                Message: message,
        }
}</span>

func NewNotFoundError(message string) *Error <span class="cov8" title="1">{
        return &amp;Error{
                Code: http.StatusNotFound,
                Message: message,
        }
}</span>

func NewUnexpectedError(message string) *Error <span class="cov8" title="1">{
        return &amp;Error{
                Code: http.StatusInternalServerError,
                Message: message,
        }
}</span>

func NewValidationError(message string) *Error <span class="cov8" title="1">{
        return &amp;Error{
                Code: http.StatusUnprocessableEntity,
                Message: message,
        }
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
